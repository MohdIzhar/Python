Implementing Collection using TDD - Test Driven Development approach.

Container - in , not in 
Sized
Iterable
Sequence
Set - various set operation intersection, union, etc

Lets build SortedSet Collection that Implements all these 5 protocols that have distinct element and constructible from an element.

Two files:
    test_sorted_set.py
    sorted_set.py

Testing iterable with generator is best way.

Part:- 1

# Running this piece of code without implementing the __contains__() will throw error (try)

class TestContainerProtocol(unittest.TestCase):
    def setUp(self):
        self.s = SortedSet([6,7,3,9])

    def test_positive_contained(self):
        self.assertTrue(6 in self.s)
    
    def test_negative_contained(self):
        self.assertFalse(2 in self.s)

    def test_positive_not_contained(self):
        self.assertTrue(5 not in self.s)

    def test_negative_not_contained(self):
        self.assertFalse(8 in self.s)

# In sorted_set.py implementing __contains__()

    def __contains__(self, item):
        return item in self._items

> run tests // now passes all


Part:- 2 (Sized Protocol)

Must not consume or modify Collection
use of len(items) function

class TestSizedProtocol(unittest.TestCase):
    def test_empty(self):
        s = SortedSet()
        self.assertEqual(len(s),0)

    def test_one(self):
        s = SortedSet([9972])
        self.assertEqual(len(s),1)

    def test_ten(self):
        s = SortedSet(range(10))
        self.assertEqual(len(s),10)

    def test_with_duplicates(self):
        s = SortedSet([99,99,99])
        self.assertEqual(len(s),1)

# Running this will fail test cases
# In sorted_set.py

    def __len__(self):
        return len(self._items)

Note: all the test cases passes except test_with_duplicates one because the SortedSet dont check for unique items
      To make this pass: self._items = sorted(set(items))

Now run all TestCase passes


Part:- 2 (Iterable Protocol - __iter__ )

# takes an iterable

class TestIterableProtocol(unittest.TestCase):
    def setUp(self):
        self.s = SortedSet([7,2,1,1,9])

    def test_iter(self):
        i = iter(self.s)
        self.assertEqual(next(i),1)
        self.assertEqual(next(i),2)
        self.assertEqual(next(i),7)
        self.assertEqual(next(i),9)
        self.assertRaises(StopIteration, lambda: next(i))

    def test_for_loop(self):
        index = 0
        expected = [1,2,7,9]
        for item in self.s:
            self.assertEqual(item, expected[index])
            index += 1

# Running TestCase will fail because of not iterable

    def __iter__(self):
        return iter(self._items)
        or use this:
        for item in self._items:
            yield item 
        this is generator and likely to be slow but both approach works



