Implementing Collection using TDD - Test Driven Development approach.

Container - in , not in 
Sized
Iterable
Sequence
Set - various set operation intersection, union, etc

Lets build SortedSet Collection that Implements all these 5 protocols that have distinct element and constructible from an element.

Two files:
    test_sorted_set.py
    sorted_set.py

Testing iterable with generator is best way.

Part:- 1

# Running this piece of code without implementing the __contains__() will throw error (try)

class TestContainerProtocol(unittest.TestCase):
    def setUp(self):
        self.s = SortedSet([6,7,3,9])

    def test_positive_contained(self):
        self.assertTrue(6 in self.s)
    
    def test_negative_contained(self):
        self.assertFalse(2 in self.s)

    def test_positive_not_contained(self):
        self.assertTrue(5 not in self.s)

    def test_negative_not_contained(self):
        self.assertFalse(8 in self.s)

# In sorted_set.py implementing __contains__()

    def __contains__(self, item):
        return item in self._items

> run tests // now passes all


Part:- 2 (Sized Protocol)

Must not consume or modify Collection
use of len(items) function

class TestSizedProtocol(unittest.TestCase):
    def test_empty(self):
        s = SortedSet()
        self.assertEqual(len(s),0)

    def test_one(self):
        s = SortedSet([9972])
        self.assertEqual(len(s),1)

    def test_ten(self):
        s = SortedSet(range(10))
        self.assertEqual(len(s),10)

    def test_with_duplicates(self):
        s = SortedSet([99,99,99])
        self.assertEqual(len(s),1)

# Running this will fail test cases
# In sorted_set.py

    def __len__(self):
        return len(self._items)

Note: all the test cases passes except test_with_duplicates one because the SortedSet dont check for unique items
      To make this pass: self._items = sorted(set(items))

Now run all TestCase passes


Part:- 2 (Iterable Protocol - __iter__ )

# takes an iterable

class TestIterableProtocol(unittest.TestCase):
    def setUp(self):
        self.s = SortedSet([7,2,1,1,9])

    def test_iter(self):
        i = iter(self.s)
        self.assertEqual(next(i),1)
        self.assertEqual(next(i),2)
        self.assertEqual(next(i),7)
        self.assertEqual(next(i),9)
        self.assertRaises(StopIteration, lambda: next(i))

    def test_for_loop(self):
        index = 0
        expected = [1,2,7,9]
        for item in self.s:
            self.assertEqual(item, expected[index])
            index += 1

# Running TestCase will fail because of not iterable

    def __iter__(self):
        return iter(self._items)
        or use this:
        for item in self._items:
            yield item 
        this is generator and likely to be slow but both approach works

Part:- 4 (Sequence Protocol - __getitem__ )

Sequence protocols - index, slicing

class TestSequenceProtocol(unittest.TestCase):
    def setUp(self):
        self.s = SortedSet([1,4,9,13,15])

    def test_index_zero(self):
        self.assertEqual(self.s[0],1)

    def test_index_four(self):
        self.assertEqual(self.s[4],15)

    def test_index_one_beyond_end(self):
        with self.assertRaises(IndexError):
            self.s[5]

    def test_index_minus_one(self):
        self.assertEqual(self.s[-1],15)

    def test_index_minus_five(self):
        self.assertEqual(self.s[-5],1)

    def test_index_one_beyond_beginning(self):
        with self.assertRaises(IndexError):
            self.s[-6]

# Running TestCase will fail

    def __getitem__(self, index):
        return self._items[index]

# slicing implementions
                                       +--> because slicing returns the sorted_set
    def test_slice_from_start(self):   |
        self.assertEqual(self.s[:3], SortedSet([1,4,9]))

    def test_slice_to_end(self):
        self.assertEqual(self.s[3:], SortedSet([13,15]))

    def test_slice_empty(self):
        self.assertEqual(self.s[10:], SortedSet())

    def test_slice_arbitrary(self):
        self.assertEqual(self.s[2:4], SortedSet([9,13]))

    def test_slice_full(self):
        self.assertEqual(self.s[:], self.s)

# Running slicing will fail TestCase

    def __getitem__(self, index):
        result = self._items[index]
        return SortedSet(result) if isinstance(index, slice) else result
        
Note: the will fail again but now for different reason of slicing

Part:- 5 (Repr protocol for debuging - __repr__ )


class TestReprProtocol(unittest.TestCase):
    def test_repr_empty(self):
        s = SortedSet()
        self.assertEqual(repr(s), "SortedSet()")

    def test_repr_some(self):
        s = SortedSet([42,48,19])
        self.assertEqual(repr(s), "SortedSet([19, 40, 48])")

# now total 7 cases will fail - 5 slicing and two repr

    def __repr__(self):
        return "SortedSet({})".format(
            repr(self._items) if self._items else ''
        )

# Now Running TestCase will pass repr tests cases
But their is another issue.


class TestEqualityProtocol(unittest.TestCase):
    def test_positive_equal(self):
        self.assertTrue(SortedSet([4,5,6]) == SortedSet([6,5,4]))

    def test_negative_equal(self):
        self.assertFalse(SortedSet([1,2,3]) == SortedSet([6,5,4]))

    def test_type_mismatch(self):
        self.assertFalse(SortedSet([4,5,6]) == [4,5,6])

    def test_identical(self):
        s  = SortedSet([10,11,12])
        self.assertTrue(s == s)

# Running TestCase fails

    def __eq__(self,rhs):
        return self._items == rhs._items

    Note:- type test_type_mismatch will still fail
        def __eq__(self,rhs):
        if not isinstance(rhs, SortedSet):
            return NotImplemented
        return self._items == rhs._items

Now all TestCase passes

Part: 6-7 (Equality and Inequality Protocol - __eq__ )

class TestInequalityProtocol(unittest.TestCase):
    def test_positive_unequal(self):
        self.assertTrue(SortedSet([4,5,6]) != SortedSet([1,2,3]))

    def test_negative_unequal(self):
        self.assertFalse(SortedSet([4,5,6]) != SortedSet([6,5,4]))

    def test_type_mismatch(self):
        self.assertTrue(SortedSet([1,2,3]) != [1,2,3])

    def test_identical(self):
        s  = SortedSet([10,11,12])
        self.assertFalse(s != s)


# this will pass all TestCase by negating the __eq__ protocol
